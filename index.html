<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="AndyYoung">
<meta property="og:url" content="http://ChinaAndy.com/index.html">
<meta property="og:site_name" content="AndyYoung">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyYoung">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ChinaAndy.com/"/>





  <title>AndyYoung</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AndyYoung</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/专用图层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安丹阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyYoung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/专用图层/" itemprop="url">专用图层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T16:02:04+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h1><h2 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h2><p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后<code>CAShapeLayer</code>就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的<code>CALyer</code>的内容中绘制一个路径，相比直下，使用<code>CAShapeLayer</code>有以下一些优点：</p>
<ul>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h3 id="创建一个CGPath"><a href="#创建一个CGPath" class="headerlink" title="创建一个CGPath"></a>创建一个<code>CGPath</code></h3><p><code>CAShapeLayer</code>可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如<code>lineWith</code>（线宽，用点表示单位），<code>lineCap</code>（线条结尾的样子），和<code>lineJoin</code>（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p>清单6.1 的代码用一个<code>CAShapeLayer</code>渲染一个简单的火柴人。<code>CAShapeLayer</code>属性是<code>CGPathRef</code>类型，但是我们用<code>UIBezierPath</code>帮助类创建了图层路径，这样我们就不用考虑人工释放<code>CGPath</code>了。图6.1是代码运行的结果。虽然还不是很完美，但是总算知道了大意对吧！</p>
<p>清单6.1 用<code>CAShapeLayer</code>绘制一个火柴人</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create path</div><div class="line">UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">[path moveToPoint:CGPointMake(175, 100)];</div><div class="line">￼</div><div class="line">[path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];</div><div class="line">[path moveToPoint:CGPointMake(150, 125)];</div><div class="line">[path addLineToPoint:CGPointMake(150, 175)];</div><div class="line">[path addLineToPoint:CGPointMake(125, 225)];</div><div class="line">[path moveToPoint:CGPointMake(150, 175)];</div><div class="line">[path addLineToPoint:CGPointMake(175, 225)];</div><div class="line">[path moveToPoint:CGPointMake(100, 150)];</div><div class="line">[path addLineToPoint:CGPointMake(200, 150)];</div><div class="line"></div><div class="line">//create shape layer</div><div class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">shapeLayer.lineWidth = 5;</div><div class="line">shapeLayer.lineJoin = kCALineJoinRound;</div><div class="line">shapeLayer.lineCap = kCALineCapRound;</div><div class="line">shapeLayer.path = path.CGPath;</div><div class="line">//add it to our view</div><div class="line">[self.containerView.layer addSublayer:shapeLayer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.1.png" alt="image"></p>
<h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>第二章里面提到了<code>CAShapeLayer</code>为创建圆角视图提供了一个方法，就是<code>CALayer</code>的<code>cornerRadius</code>属性。虽然使用<code>CAShapeLayer</code>类需要更多的工作，但是它有一个优势就是可以单独指定每个角。</p>
<p>我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上<code>UIBezierPath</code>有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//define path parameters</div><div class="line">CGRect rect = CGRectMake(50, 50, 100, 100);</div><div class="line">CGSize radii = CGSizeMake(20, 20);</div><div class="line">UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;</div><div class="line">//create path</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</div></pre></td></tr></table></figure>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把<code>CAShapeLayer</code>作为视图的宿主图层，而不是添加一个子视图（图层蒙板的详细解释见第四章『视觉效果』）。</p>
<h2 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h2><p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。</p>
<p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。</p>
<p>万幸的是这些都是不必要的，Core Animation提供了一个CALayer的子类<code>CATextLayer</code>，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，<code>CATextLayer</code>也要比<code>UILabel</code>渲染得快得多。很少有人知道在iOS 6及之前的版本，<code>UILabel</code>其实是通过<code>WebKit</code>来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而<code>CATextLayer</code>使用了<code>Core text</code>，并且渲染得非常快。</p>
<p>让我们来尝试用<code>CATextLayer</code>来显示一些文字。清单6.2的代码实现了这一功能，结果如图6.2所示。</p>
<p>清单6.2 用CATextLayer来实现一个UILabel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create a text layer</div><div class="line">CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">textLayer.frame = self.labelView.bounds;</div><div class="line">[self.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">textLayer.foregroundColor = [UIColor blackColor].CGColor;</div><div class="line">textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">textLayer.wrapped = YES;</div><div class="line"></div><div class="line">//choose a font</div><div class="line">UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line"></div><div class="line">//set layer font</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">textLayer.font = fontRef;</div><div class="line">textLayer.fontSize = font.pointSize;</div><div class="line">CGFontRelease(fontRef);</div><div class="line"></div><div class="line">//choose some text</div><div class="line">NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line"></div><div class="line">//set layer text</div><div class="line">textLayer.string = text;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.2.png" alt=""></p>
<p>图6.2 用<code>CATextLayer</code>来显示一个纯文本标签</p>
<p>如果你仔细看这个文本，你会发现一个奇怪的地方：这些文本有一些像素化了。这是因为并没有以Retina的方式渲染，第二章提到了这个<code>contentScale</code>属性，用来决定图层内容应该以怎样的分辨率来渲染。<code>contentsScale</code>并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下：</p>
<p>textLayer.contentsScale = [UIScreen mainScreen].scale;<br>这样就解决了这个问题（如图6.3）</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.3.png" alt="i"></p>
<p>图6.3 设置contentsScale来匹配屏幕</p>
<p><code>CATextLayer</code>的<code>font</code>属性不是一个<code>UIFont</code>类型，而是一个<code>CFTypeRef</code>类型。这样可以根据你的具体需要来决定字体属性应该是用<code>CGFontRef</code>类型还是<code>CTFontRef</code>类型（Core Text字体）。同时字体大小也是用<code>fontSize</code>属性单独设置的，因为<code>CTFontRef</code>和<code>CGFontRef</code>并不像<code>UIFont</code>一样包含点大小。这个例子会告诉你如何将<code>UIFont</code>转换成<code>CGFontRef</code>。</p>
<p>另外，<code>CATextLayer</code>的<code>string</code>属性并不是你想象的<code>NSString</code>类型，而是<code>id</code>类型。这样你既可以用<code>NSString</code>也可以用<code>NSAttributedString</code>来指定文本了（注意，<code>NSAttributedString</code>并不是<code>NSString</code>的子类）。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>
<h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><p>iOS 6中，Apple给<code>UILabel</code>和其他UIKit文本视图添加了直接的属性化字符串的支持，应该说这是一个很方便的特性。不过事实上从iOS3.2开始<code>CATextLayer</code>就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，CATextLayer无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用UIWebView的麻烦。</p>
<p>让我们编辑一下示例使用到<code>NSAttributedString</code>（见清单6.3）.iOS 6及以上我们可以用新的<code>NSTextAttributeName</code>实例来设置我们的字符串属性，但是练习的目的是为了演示在iOS 5及以下，所以我们用了<code>Core Text</code>，也就是说你需要把Core Text framework添加到你的项目中。否则，编译器是无法识别属性常量的。</p>
<p>图6.4是代码运行结果（注意那个红色的下划线文本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;CoreText/CoreText.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create a text layer</div><div class="line">CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">textLayer.frame = self.labelView.bounds;</div><div class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</div><div class="line">[self.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">textLayer.wrapped = YES;</div><div class="line"></div><div class="line">//choose a font</div><div class="line">UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line"></div><div class="line">//choose some text</div><div class="line">NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line">￼</div><div class="line">//create attributed string</div><div class="line">NSMutableAttributedString *string = nil;</div><div class="line">string = [[NSMutableAttributedString alloc] initWithString:text];</div><div class="line"></div><div class="line">//convert UIFont to a CTFont</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFloat fontSize = font.pointSize;</div><div class="line">CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">NSDictionary *attribs = @&#123;</div><div class="line">(__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,</div><div class="line">(__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[string setAttributes:attribs range:NSMakeRange(0, [text length])];</div><div class="line">attribs = @&#123;</div><div class="line">(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,</div><div class="line">(__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),</div><div class="line">(__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">&#125;;</div><div class="line">[string setAttributes:attribs range:NSMakeRange(6, 5)];</div><div class="line"></div><div class="line">//release the CTFont we created earlier</div><div class="line">CFRelease(fontRef);</div><div class="line"></div><div class="line">//set layer text</div><div class="line">textLayer.string = string;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="行距和字距"><a href="#行距和字距" class="headerlink" title="行距和字距"></a>行距和字距</h3><p>有必要提一下的是，由于绘制的实现机制不同（Core Text和WebKit），用<code>CATextLayer</code>渲染和用<code>UILabel</code>渲染出的文本行距和字距也不是不尽相同的。</p>
<p>二者的差异程度（由使用的字体和字符决定）总的来说挺小，但是如果你想正确的显示普通便签和<code>CATextLayer</code>就一定要记住这一点。</p>
<h3 id="UILabel的替代品"><a href="#UILabel的替代品" class="headerlink" title="UILabel的替代品"></a>UILabel的替代品</h3><p>我们已经证实了<code>CATextLayer</code>比<code>UILabel</code>有着更好的性能表现，同时还有额外的布局选项并且在iOS 5上支持富文本。但是与一般的标签比较而言会繁琐一些。如果我们真的在需求一个UILabel的可用替代品，最好是能够在Interface Builder上创建我们的标签，而且尽可能地像一般的视图一样正常工作。</p>
<p>我们应该继承UILabel，然后添加一个子图层CATextLayer并重写显示文本的方法。但是仍然会有由UILabel的<code>-drawRect:</code>方法创建的空寄宿图。而且由于<code>CALayer</code>不支持自动缩放和自动布局，子视图并不是主动跟踪视图边界的大小，所以每次视图大小被更改，我们不得不手动更新子图层的边界。</p>
<p>我们真正想要的是一个用<code>CATextLayer</code>作为宿主图层的<code>UILabel</code>子类，这样就可以随着视图自动调整大小而且也没有冗余的寄宿图啦。</p>
<p>就像我们在第一章『图层树』讨论的一样，每一个UIView都是寄宿在一个CALayer的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用<code>+layerClass</code>方法，然后用它的返回类型来创建宿主图层。</p>
<p>清单6.4 演示了一个UILabel子类<code>LayerLabel</code>用CATextLayer绘制它的问题，而不是调用一般的UILabel使用的较慢的<code>-drawRect：</code>方法。<code>LayerLabel</code>示例既可以用代码实现，也可以在Interface Builder实现，只要把普通的标签拖入视图之中，然后设置它的类是LayerLabel就可以了。<br>清单6.4 使用<code>CATextLayer的UILabel</code>子类：<code>LayerLabel</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#import &quot;LayerLabel.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@implementation LayerLabel</div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">//this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer</div><div class="line">return [CATextLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CATextLayer *)textLayer</div><div class="line">&#123;</div><div class="line">return (CATextLayer *)self.layer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//set defaults from UILabel settings</div><div class="line">self.text = self.text;</div><div class="line">self.textColor = self.textColor;</div><div class="line">self.font = self.font;</div><div class="line"></div><div class="line">//we should really derive these from the UILabel settings too</div><div class="line">//but that&apos;s complicated, so for now we&apos;ll just hard-code them</div><div class="line">[self textLayer].alignmentMode = kCAAlignmentJustified;</div><div class="line">￼</div><div class="line">[self textLayer].wrapped = YES;</div><div class="line">[self.layer display];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//called when creating label programmatically</div><div class="line">if (self = [super initWithFrame:frame]) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">//called when creating label using Interface Builder</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setText:(NSString *)text</div><div class="line">&#123;</div><div class="line">super.text = text;</div><div class="line">//set layer text</div><div class="line">[self textLayer].string = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setTextColor:(UIColor *)textColor</div><div class="line">&#123;</div><div class="line">super.textColor = textColor;</div><div class="line">//set layer text color</div><div class="line">[self textLayer].foregroundColor = textColor.CGColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setFont:(UIFont *)font</div><div class="line">&#123;</div><div class="line">super.font = font;</div><div class="line">//set layer font</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">[self textLayer].font = fontRef;</div><div class="line">[self textLayer].fontSize = font.pointSize;</div><div class="line">￼</div><div class="line">CGFontRelease(fontRef);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你运行代码，你会发现文本并没有像素化，而我们也没有设置<code>contentsScale</code>属性。把<code>CATextLayer</code>作为宿主图层的另一好处就是视图自动设置了<code>contentsScale</code>属性。</p>
<p>在这个简单的例子中，我们只是实现了<code>UILabel</code>的一部分风格和布局属性，不过稍微再改进一下我们就可以创建一个支持<code>UILabel</code>所有功能甚至更多功能的LayerLabel类（你可以在一些线上的开源项目中找到）。</p>
<p>如果你打算支持iOS 6及以上，基于<code>CATextLayer</code>的标签可能就有有些局限性。但是总得来说，如果想在app里面充分利用<code>CALayer</code>子类，用<code>+layerClass</code>来创建基于不同图层的视图是一个简单可复用的方法。</p>
<h2 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h2><p>当我们在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。比如说，你想创造一个孩子的手臂：你就需要确定哪一部分是孩子的手腕，哪一部分是孩子的前臂，哪一部分是孩子的肘，哪一部分是孩子的上臂，哪一部分是孩子的肩膀等等。</p>
<p>当然是允许独立地移动每个区域的啦。以肘为指点会移动前臂和手，而不是肩膀。Core Animation图层很容易就可以让你在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的孩子都平面化到一个场景中（第五章『变换』有提到）。</p>
<p><code>CATransformLayer</code>解决了这个问题，<code>CATransformLayer</code>不同于普通的<code>CALayer</code>，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。<code>CATransformLayer</code>并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，比如我的手臂示例。</p>
<p>用代码创建一个手臂需要相当多的代码，所以我就演示得更简单一些吧：在第五章的立方体示例，我们将通过旋转camara来解决图层平面化问题而不是像立方体示例代码中用的<code>sublayerTransform</code>。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>
<p>那么，就让我们来试一试<code>CATransformLayer</code>吧，第一个问题就来了：在第五章，我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的UIView子类寄宿在CATransformLayer（用+layerClass方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像第五章一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>
<p>清单6.5就是代码。我们以我们在第五章使用过的相同基本逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个CATransformLayer中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是光亮来区分他们。图6.5是运行结果。</p>
<p>… 此处省略三千字</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的。用<code>Core Graphics</code>复制一个<code>CAGradientLayer</code>并将内容绘制到一个普通图层的寄宿图也是有可能的，但是<code>CAGradientLayer</code>的真正好处在于绘制使用了硬件加速。</p>
<h3 id="基础渐变"><a href="#基础渐变" class="headerlink" title="基础渐变"></a>基础渐变</h3><p>我们将从一个简单的红变蓝的对角线渐变开始（见清单6.6）.这些渐变色彩放在一个数组中，并赋给<code>colors</code>属性。这个数组成员接受<code>CGColorRef</code>类型的值（并不是从NSObject派生而来），所以我们要用通过bridge转换以确保编译正常。</p>
<p><code>CAGradientLayer</code>也有<code>startPoint</code>和<code>endPoint</code>属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是<code>{0, 0}</code>，右下角坐标是<code>{1, 1}</code>。代码运行结果如图6.6</p>
<p>清单6.6 简单的两种颜色的对角线渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create gradient layer and add it to our container view</div><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">//set gradient colors</div><div class="line">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];</div><div class="line"></div><div class="line">//set gradient start and end points</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="多重渐变"><a href="#多重渐变" class="headerlink" title="多重渐变"></a>多重渐变</h3><p>如果你愿意，<code>colors</code>属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用<code>locations</code>属性来调整空间。<code>locations</code>属性是一个浮点数值的数组（以<code>NSNumber</code>包装）。这些浮点数定义了<code>colors</code>属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。</p>
<p><code>locations</code>数组并不是强制要求的，但是如果你给它赋值了就一定要确保<code>locations</code>的数组大小和<code>colors</code>数组大小一定要相同，否则你将会得到一个空白的渐变。</p>
<p>清单6.7展示了一个基于清单6.6的对角线渐变的代码改造。现在变成了从红到黄最后到绿色的渐变。<code>locations</code>数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。（如图6.7）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create gradient layer and add it to our container view</div><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">//set gradient colors</div><div class="line">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];</div><div class="line"></div><div class="line">//set locations</div><div class="line">gradientLayer.locations = @[@0.0, @0.25, @0.5];</div><div class="line"></div><div class="line">//set gradient start and end points</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。看上去演示能够更加解释这些，我们来写个例子吧。</p>
<p>变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上，图6.8是代码运行结果。</p>
<p>清单6.8 用<code>CAReplicatorLayer</code>重复图层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create a replicator layer and add it to our view</div><div class="line">CAReplicatorLayer *replicator = [CAReplicatorLayer layer];</div><div class="line">replicator.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:replicator];</div><div class="line"></div><div class="line">//configure the replicator</div><div class="line">replicator.instanceCount = 10;</div><div class="line"></div><div class="line">//apply a transform for each instance</div><div class="line">CATransform3D transform = CATransform3DIdentity;</div><div class="line">transform = CATransform3DTranslate(transform, 0, 200, 0);</div><div class="line">transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);</div><div class="line">transform = CATransform3DTranslate(transform, 0, -200, 0);</div><div class="line">replicator.instanceTransform = transform;</div><div class="line"></div><div class="line">//apply a color shift for each instance</div><div class="line">replicator.instanceBlueOffset = -0.1;</div><div class="line">replicator.instanceGreenOffset = -0.1;</div><div class="line"></div><div class="line">//create a sublayer and place it inside the replicator</div><div class="line">CALayer *layer = [CALayer layer];</div><div class="line">layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);</div><div class="line">layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">[replicator addSublayer:layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.8.png" alt="image"></p>
<p>注意到当图层在重复的时候，他们的颜色也在变化：这是用<code>instanceBlueOffset</code>和<code>instanceGreenOffset</code>属性实现的。通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是CAReplicatorLayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了CAEmitterLayer，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：反射。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>使用<code>CAReplicatorLayer</code>并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果。让我们来尝试实现这个创意：指定一个继承于<code>UIView的ReflectionView</code>，它会自动产生内容的反射效果。实现这个效果的代码很简单（见清单6.9），实际上用<code>ReflectionView</code>实现这个效果会更简单，我们只需要把<code>ReflectionView</code>的实例放置于Interface Builder（见图6.9），它就会实时生成子视图的反射，而不需要别的代码（见图6.10）.</p>
<p>清单6.9 用CAReplicatorLayer自动绘制反射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#import &quot;ReflectionView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@implementation ReflectionView</div><div class="line"></div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">return [CAReplicatorLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//configure replicator</div><div class="line">CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;</div><div class="line">layer.instanceCount = 2;</div><div class="line"></div><div class="line">//move reflection instance below original and flip vertically</div><div class="line">CATransform3D transform = CATransform3DIdentity;</div><div class="line">CGFloat verticalOffset = self.bounds.size.height + 2;</div><div class="line">transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);</div><div class="line">transform = CATransform3DScale(transform, 1, -1, 0);</div><div class="line">layer.instanceTransform = transform;</div><div class="line"></div><div class="line">//reduce alpha of reflection layer</div><div class="line">layer.instanceAlphaOffset = -0.6;</div><div class="line">&#125;</div><div class="line">￼</div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//this is called when view is created in code</div><div class="line">if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">//this is called when view is created from a nib</div><div class="line">[self setUp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.10.png" alt=""></p>
<p>开源代码ReflectionView完成了一个自适应的渐变淡出效果（用CAGradientLayer和图层蒙板实现），代码见 <a href="https://github.com/nicklockwood/ReflectionView" target="_blank" rel="external">https://github.com/nicklockwood/ReflectionView</a></p>
<h2 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h2><p>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。</p>
<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到UITableView或是UIScrollView，但是对于独立的图层来说，什么会等价于刚刚提到的UITableView和UIScrollView呢？</p>
<p>在第二章中，我们探索了图层的contentsRect属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>
<p>这个时候就需要CAScrollLayer了。CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<p>让我们来用CAScrollLayer来常见一个基本的UIScrollView替代品。我们将会用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应。这段代码见清单6.10. 图6.11是运行效果：ScrollView显示了一个大于它的frame的UIImageView。</p>
<p>清单6.10 用CAScrollLayer实现滑动视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#import &quot;ScrollView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt; @implementation ScrollView</div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">return [CAScrollLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//enable clipping</div><div class="line">self.layer.masksToBounds = YES;</div><div class="line"></div><div class="line">//attach pan gesture recognizer</div><div class="line">UIPanGestureRecognizer *recognizer = nil;</div><div class="line">recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</div><div class="line">[self addGestureRecognizer:recognizer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//this is called when view is created in code</div><div class="line">if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">//this is called when view is created from a nib</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)pan:(UIPanGestureRecognizer *)recognizer</div><div class="line">&#123;</div><div class="line">//get the offset by subtracting the pan gesture</div><div class="line">//translation from the current bounds origin</div><div class="line">CGPoint offset = self.bounds.origin;</div><div class="line">offset.x -= [recognizer translationInView:self].x;</div><div class="line">offset.y -= [recognizer translationInView:self].y;</div><div class="line"></div><div class="line">//scroll the layer</div><div class="line">[(CAScrollLayer *)self.layer scrollToPoint:offset];</div><div class="line"></div><div class="line">//reset the pan gesture translation</div><div class="line">[recognizer setTranslation:CGPointZero inView:self];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>图6.11 用UIScrollView创建一个凑合的滑动视图</p>
<p>不同于UIScrollView，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</p>
<p>那你一定会奇怪用CAScrollLayer的意义到底何在，因为你可以简单地用一个普通的CALayer然后手动适应边界原点啊。真相其实并不复杂，UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>
<p>CAScrollLayer有一个潜在的有用特性。如果你查看CAScrollLayer的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)scrollPoint:(CGPoint)p;</div><div class="line">- (void)scrollRectToVisible:(CGRect)r;</div><div class="line">@property(readonly) CGRect visibleRect;</div></pre></td></tr></table></figure>
<p>看到这些方法和属性名，你也许会以为这些方法给每个CALayer实例增加了滑动功能。但是事实上他们只是放置在CAScrollLayer中的图层的实用方法。scrollPoint:方法从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。scrollRectToVisible:方法实现了同样的事情只不过是作用在一个矩形上的。visibleRect属性决定图层（如果存在的话）的哪部分是当前的可视区域。如果你自己实现这些方法就会相对容易明白一点，但是CAScrollLayer帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</p>
<h2 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h2><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的<code>-imageNamed:</code>方法或者<code>-imageWithContentsOfFile:</code>方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>
<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为<code>OpenGL</code>纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em>2048，或4096</em>4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p>
<p><code>CATiledLayer</code>为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</p>
<h3 id="小片裁剪"><a href="#小片裁剪" class="headerlink" title="小片裁剪"></a>小片裁剪</h3><p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从<code>CATiledLayer</code>中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那<code>CATiledLayer</code>这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>
<p>清单6.11 演示了一个简单的Mac OS命令行程序，它用<code>CATiledLayer</code>将一个图片裁剪成小图并存储到不同的文件中。</p>
<p>清单6.11 裁剪图片成小图的终端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#import &lt;AppKit/AppKit.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[])</div><div class="line">&#123;</div><div class="line">@autoreleasepool&#123;</div><div class="line">￼//handle incorrect arguments</div><div class="line">if (argc &lt; 2) &#123;</div><div class="line">NSLog(@&quot;TileCutter arguments: inputfile&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//input file</div><div class="line">NSString *inputFile = [NSString stringWithCString:argv[1] encoding:NSUTF8StringEncoding];</div><div class="line"></div><div class="line">//tile size</div><div class="line">CGFloat tileSize = 256; //output path</div><div class="line">NSString *outputPath = [inputFile stringByDeletingPathExtension];</div><div class="line"></div><div class="line">//load image</div><div class="line">NSImage *image = [[NSImage alloc] initWithContentsOfFile:inputFile];</div><div class="line">NSSize size = [image size];</div><div class="line">NSArray *representations = [image representations];</div><div class="line">if ([representations count])&#123;</div><div class="line">NSBitmapImageRep *representation = representations[0];</div><div class="line">size.width = [representation pixelsWide];</div><div class="line">size.height = [representation pixelsHigh];</div><div class="line">&#125;</div><div class="line">NSRect rect = NSMakeRect(0.0, 0.0, size.width, size.height);</div><div class="line">CGImageRef imageRef = [image CGImageForProposedRect:&amp;rect context:NULL hints:nil];</div><div class="line"></div><div class="line">//calculate rows and columns</div><div class="line">NSInteger rows = ceil(size.height / tileSize);</div><div class="line">NSInteger cols = ceil(size.width / tileSize);</div><div class="line"></div><div class="line">//generate tiles</div><div class="line">for (int y = 0; y &lt; rows; ++y) &#123;</div><div class="line">for (int x = 0; x &lt; cols; ++x) &#123;</div><div class="line">//extract tile image</div><div class="line">CGRect tileRect = CGRectMake(x*tileSize, y*tileSize, tileSize, tileSize);</div><div class="line">CGImageRef tileImage = CGImageCreateWithImageInRect(imageRef, tileRect);</div><div class="line"></div><div class="line">//convert to jpeg data</div><div class="line">NSBitmapImageRep *imageRep = [[NSBitmapImageRep alloc] initWithCGImage:tileImage];</div><div class="line">NSData *data = [imageRep representationUsingType: NSJPEGFileType properties:nil];</div><div class="line">CGImageRelease(tileImage);</div><div class="line"></div><div class="line">//save file</div><div class="line">NSString *path = [outputPath stringByAppendingFormat: @&quot;_%02i_%02i.jpg&quot;, x, y];</div><div class="line">[data writeToFile:path atomically:NO];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序将2048<em>2048分辨率的雪人图案裁剪成了64个不同的256</em>256的小图。（256*256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>
<blockquote>
<p>path/to/TileCutterApp path/to/Snowman.jpg</p>
</blockquote>
<h2 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h2><p>在iOS 5中，苹果引入了一个新的<code>CALayer</code>子类叫做<code>CAEmitterLayer</code>。<code>CAEmitterLayer</code>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<p><code>CAEmitterLayer</code>看上去像是许多<code>CAEmitterCell</code>的容器，这些<code>CAEmitierCell</code>定义了一个例子效果。你将会为不同的例子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。一个<code>CAEmitterCell</code>类似于一个<code>CALayer：</code>它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在<code>CAEmitterCell</code>类的头文件中找到。</p>
<p>我们来举个例子。我们将利用在一圆中发射不同速度和透明度的粒子创建一个火爆炸的效果。清单6.13包含了生成爆炸的代码。图6.13是运行结果</p>
<p>清单6.13 用<code>CAEmitterLayer</code>创建爆炸效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">￼</div><div class="line">//create particle emitter layer</div><div class="line">CAEmitterLayer *emitter = [CAEmitterLayer layer];</div><div class="line">emitter.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:emitter];</div><div class="line"></div><div class="line">//configure emitter</div><div class="line">emitter.renderMode = kCAEmitterLayerAdditive;</div><div class="line">emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);</div><div class="line"></div><div class="line">//create a particle template</div><div class="line">CAEmitterCell *cell = [[CAEmitterCell alloc] init];</div><div class="line">cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;</div><div class="line">cell.birthRate = 150;</div><div class="line">cell.lifetime = 5.0;</div><div class="line">cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;</div><div class="line">cell.alphaSpeed = -0.4;</div><div class="line">cell.velocity = 50;</div><div class="line">cell.velocityRange = 50;</div><div class="line">cell.emissionRange = M_PI * 2.0;</div><div class="line"></div><div class="line">//add particle template to emitter</div><div class="line">emitter.emitterCells = @[cell];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>CAEMitterCell的属性基本上可以分为三种：</p>
<ul>
<li>这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>例子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</li>
</ul>
<p><code>CAEmitterLayer</code>的属性它自己控制着整个例子系统的位置和形状。一些属性比如<code>birthRate</code>，<code>lifetime</code>和<code>celocity</code>，这些属性在<code>CAEmitterCell</code>中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：</p>
<ul>
<li><code>preservesDepth</code>，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li><code>renderMode</code>，控制着在视觉上粒子图片是如何混合的。你可能已经注意到了示例中我们把它设置为<code>kCAEmitterLayerAdditive</code>，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的<code>kCAEmitterLayerUnordered</code>，效果就没那么好看了（见图6.14）.<br><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.14.png" alt="i"></li>
</ul>
<p>图6.14 禁止混色之后的火焰粒子</p>
<h2 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h2><p>当iOS要处理高性能图形绘制，必要时就是OpenGL。应该说它应该是最后的杀手锏，至少对于非游戏的应用来说是的。因为相比Core Animation和UIkit框架，它不可思议地复杂。</p>
<p>OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。用起来非常复杂和强大，但是用OpenGL绘制iOS用户界面就需要很多很多的工作了。</p>
<p>为了能够以高性能使用Core Animation，你需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果你想绘制的东西并不能找到标准的图层类，想要得到高性能就比较费事情了。</p>
<p>因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<p>大部分情况下你都不需要手动设置CAEAGLLayer（假设用GLKView），过去的日子就不要再提了。特别的，我们将设置一个OpenGL ES 2.0的上下文，它是现代的iOS设备的标准做法。</p>
<p>尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，这些都以类C语言叫做GLSL自包含在程序中，同时在运行时载入到图形硬件中。编写GLSL代码和设置EAGLayer没有什么关系，所以我们将用GLKBaseEffect类将着色逻辑抽象出来。其他的事情，我们还是会有以往的方式。</p>
<p>在开始之前，你需要将GLKit和OpenGLES框架加入到你的项目中，然后就可以实现清单6.14中的代码，里面是设置一个GAEAGLLayer的最少工作，它使用了OpenGL ES 2.0 的绘图上下文，并渲染了一个有色三角（见图6.15）.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/图层几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安丹阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyYoung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/图层几何学/" itemprop="url">图层几何学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T16:00:29+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图层几何学"><a href="#图层几何学" class="headerlink" title="图层几何学"></a>图层几何学</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>之前提到过，视图的<code>center</code>属性和图层的<code>position</code>属性都指定了<code>anchorPoint</code>相对于父图层的位置。图层的<code>anchorPoint</code>通过<code>position</code>来控制它的<code>frame</code>的位置，你可以认为<code>anchorPoint</code>是用来移动图层的把柄。</p>
<p>默认来说，<code>anchorPoint</code>位于图层的中点，所以图层的将会以这个点为中心放置。<code>anchorPoint</code>属性并没有被UIView接口暴露出来，这也是视图的<code>position</code>属性被叫做“center”的原因。但是图层的<code>anchorPoint</code>可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/3.3.jpeg" alt="image"></p>
<p>和第二章提到的<code>contentsRect</code>和<code>contentsCenter</code>属性类似，<code>anchorPoint</code>用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。<code>anchorPoint</code>可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了<code>anchorPoint</code>，<code>position</code>属性保持固定的值并没有发生改变，但是<code>frame</code>却移动了。</p>
<p>那在什么场合需要改变<code>anchorPoint</code>呢？既然我们可以随意改变图层位置，那改变<code>anchorPoint</code>不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView实例（当然你也可以用正常的视图，设置他们图层的contents图片）。</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/3.4.jpeg" alt="clock"></p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/3.6.jpeg" alt="image"></p>
<p>清单3.1 Clock</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">// adjust anchor points</div><div class="line"></div><div class="line">self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); </div><div class="line">self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); </div><div class="line">self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line"></div><div class="line">//start timer</div><div class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">￼</div><div class="line">//set initial hand positions</div><div class="line">[self tick];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">//convert time to hours, minutes and seconds</div><div class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">//calculate hour hand angle //calculate minute hand angle</div><div class="line">CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">//calculate second hand angle</div><div class="line">CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">//rotate hands</div><div class="line">self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/3.7.jpeg" alt=""></p>
<h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。</p>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</p>
<p>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<ul>
<li>(CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; </li>
<li>(CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; </li>
<li>(CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</li>
<li>(CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</li>
</ul>
<h2 id="翻转的几何结构"><a href="#翻转的几何结构" class="headerlink" title="翻转的几何结构"></a>翻转的几何结构</h2><p>常规说来，在iOS上，一个图层的<code>position</code>位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过<code>geometryFlipped</code>属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的<code>geometryFlipped</code>属性也设为YES）。</p>
<h2 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h2><p>自动布局</p>
<p>你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。</p>
<p>在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)layoutSublayersOfLayer:(CALayer *)layer;</div></pre></td></tr></table></figure>
<p>当图层的bounds发生改变，或者图层的-setNeedsLayout方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像UIView的autoresizingMask和constraints属性做到自适应屏幕旋转。</p>
<p>这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。</p>
<p>总结</p>
<p>本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/寄宿图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安丹阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyYoung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/寄宿图/" itemprop="url">寄宿图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T15:57:59+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="寄宿图"><a href="#寄宿图" class="headerlink" title="寄宿图"></a>寄宿图</h2><p><code>CALayer</code> 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p>
<h3 id="contents属性"><a href="#contents属性" class="headerlink" title="contents属性"></a>contents属性</h3><p><code>contents</code>这个奇怪的表现是由<code>Mac OS</code>的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p>
<p><code>layer.contents = (__bridge id)image.CGImage;</code><br><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.1.png" alt="Alt text"></p>
<h3 id="contentGravity"><a href="#contentGravity" class="headerlink" title="contentGravity"></a>contentGravity</h3><p><code>CALayer</code>与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个<code>NSString</code>类型，而不是像对应的<code>UIKit</code>部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill<br>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</li>
</ul>
<p><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code></p>
<h3 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h3><p><code>contentsScale</code>属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p><code>contentsScale</code>的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为<code>contents</code>由于设置了<code>contentsGravity</code>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的<code>contents</code>图片，你可以通过使用图层的<code>transform</code>和<code>affineTransform</code>属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是<code>contentsScale</code>的目的所在.</p>
<p><code>contentsScale</code>属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置contentsGravity属性）。UIView有一个类似功能但是非常少用到的<code>contentScaleFactor</code>属性。</p>
<p>如果<code>contentsScale</code>设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用<code>kCAGravityResizeAspect</code>时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把<code>contentsGravity</code>设置为<code>kCAGravityCenter</code>（这个值并不会拉伸图片），那将会有很明显的变化.</p>
<h3 id="maskToBounds"><a href="#maskToBounds" class="headerlink" title="maskToBounds"></a>maskToBounds</h3><p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，<code>UIView</code>仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p><code>UIView</code>有一个叫做<code>clipsToBounds</code>的属性可以用来决定是否显示超出边界的内容，<code>CALayer</code>对应的属性叫做<code>masksToBounds</code>，把它设置为YES，雪人就在边界里啦～</p>
<h3 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h3><p>CALayer的<code>contentsRect</code>属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比<code>contentsGravity</code>灵活多了</p>
<p>和<font color="#0099ff" size="5" face="黑体"><code>bounds</code>，<code>frame</code></font>不同，<code>contentsRect</code>不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。<br>默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）<br><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.6.png" alt="image"></li>
</ul>
<p>事实上给<code>contentsRect</code>设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p><code>contentsRect</code>在app中最有趣的地方在于一个叫做<code>image sprites</code>（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等.</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.7.png" alt="contentsRect"></p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *coneView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *shipView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *iglooView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *anchorView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image</div><div class="line">&#123;</div><div class="line">layer.contents = (__bridge id)image.CGImage;</div><div class="line"></div><div class="line">//scale contents to fit</div><div class="line">layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line"></div><div class="line">//set contentsRect</div><div class="line">layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad </div><div class="line">&#123;</div><div class="line">[super viewDidLoad]; //load sprite sheet</div><div class="line">UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];</div><div class="line">//set igloo sprite</div><div class="line">[self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];</div><div class="line">//set cone sprite</div><div class="line">[self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];</div><div class="line">//set anchor sprite</div><div class="line">[self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];</div><div class="line">//set spaceship sprite</div><div class="line">[self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.8.png" alt="contentsRect"></p>
<h3 id="contentsCenter-九宫格"><a href="#contentsCenter-九宫格" class="headerlink" title="contentsCenter(九宫格)"></a>contentsCenter(九宫格)</h3><p><code>contentsCenter</code>其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变<code>contentsCenter</code>的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.10.png" alt="contentsCenter"></p>
<h3 id="Custome-Drawing"><a href="#Custome-Drawing" class="headerlink" title="Custome Drawing"></a>Custome Drawing</h3><p>给<code>contents</code>赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现<code>-drawRect:</code>方法来自定义绘制。</p>
<p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的<code>-drawRect:</code>方法。</p>
<p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了<code>-setNeedsDisplay</code>方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的<code>图片</code>。</p>
<p>CALayer有一个可选的<code>delegate</code>属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate <code>@protocol</code>可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(void)displayLayer:(CALayerCALayer *)layer;</div></pre></td></tr></table></figure>
<p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</div></pre></td></tr></table></figure>
<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">￼</div><div class="line">//create sublayer</div><div class="line">CALayer *blueLayer = [CALayer layer];</div><div class="line">blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line"></div><div class="line">//set controller as layer delegate</div><div class="line">blueLayer.delegate = self;</div><div class="line"></div><div class="line">//ensure that layer backing image uses correct scale</div><div class="line">blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view</div><div class="line">[self.layerView.layer addSublayer:blueLayer];</div><div class="line"></div><div class="line">//force layer to redraw</div><div class="line">[blueLayer display];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class="line">&#123;</div><div class="line">//draw a thick red circle</div><div class="line">CGContextSetLineWidth(ctx, 10.0f); </div><div class="line">CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);</div><div class="line">CGContextStrokeEllipseInRect(ctx, layer.bounds);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/2.12.png" alt="image"></p>
<p>注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了<code>-display</code>。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>当使用寄宿了视图的图层的时候，你也不必实现<code>-displayLayer:</code>和<code>-drawLayer:inContext:</code>方法来绘制你的寄宿图。通常做法是实现UIView的<code>-drawRect:</code>方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用<code>-display</code>方法。</p>
<p>#总结<br>本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/FirstArticle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安丹阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyYoung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/FirstArticle/" itemprop="url">FirstArticle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T15:39:45+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="安丹阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyYoung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/hello-world/" itemprop="url">FirstArticle an ananaana</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T14:52:30+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="安丹阳" />
          <p class="site-author-name" itemprop="name">安丹阳</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安丹阳</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
