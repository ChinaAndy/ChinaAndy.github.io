<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="专用图层CAShapeLayerCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：  渲染快速。CAShapeLayer">
<meta property="og:type" content="article">
<meta property="og:title" content="专用图层">
<meta property="og:url" content="http://ChinaAndy.com/2017/07/06/专用图层/index.html">
<meta property="og:site_name" content="安丹阳">
<meta property="og:description" content="专用图层CAShapeLayerCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：  渲染快速。CAShapeLayer">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.1.png">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.2.png">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.3.png">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.8.png">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.10.png">
<meta property="og:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.14.png">
<meta property="og:updated_time" content="2017-07-06T08:02:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="专用图层">
<meta name="twitter:description" content="专用图层CAShapeLayerCAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：  渲染快速。CAShapeLayer">
<meta name="twitter:image" content="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ChinaAndy.com/2017/07/06/专用图层/"/>





  <title>专用图层 | 安丹阳</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安丹阳</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ChinaAndy.com/2017/07/06/专用图层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安丹阳">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">专用图层</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-06T16:02:04+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h1><h2 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h2><p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后<code>CAShapeLayer</code>就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的<code>CALyer</code>的内容中绘制一个路径，相比直下，使用<code>CAShapeLayer</code>有以下一些优点：</p>
<ul>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h3 id="创建一个CGPath"><a href="#创建一个CGPath" class="headerlink" title="创建一个CGPath"></a>创建一个<code>CGPath</code></h3><p><code>CAShapeLayer</code>可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如<code>lineWith</code>（线宽，用点表示单位），<code>lineCap</code>（线条结尾的样子），和<code>lineJoin</code>（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p>清单6.1 的代码用一个<code>CAShapeLayer</code>渲染一个简单的火柴人。<code>CAShapeLayer</code>属性是<code>CGPathRef</code>类型，但是我们用<code>UIBezierPath</code>帮助类创建了图层路径，这样我们就不用考虑人工释放<code>CGPath</code>了。图6.1是代码运行的结果。虽然还不是很完美，但是总算知道了大意对吧！</p>
<p>清单6.1 用<code>CAShapeLayer</code>绘制一个火柴人</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create path</div><div class="line">UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">[path moveToPoint:CGPointMake(175, 100)];</div><div class="line">￼</div><div class="line">[path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];</div><div class="line">[path moveToPoint:CGPointMake(150, 125)];</div><div class="line">[path addLineToPoint:CGPointMake(150, 175)];</div><div class="line">[path addLineToPoint:CGPointMake(125, 225)];</div><div class="line">[path moveToPoint:CGPointMake(150, 175)];</div><div class="line">[path addLineToPoint:CGPointMake(175, 225)];</div><div class="line">[path moveToPoint:CGPointMake(100, 150)];</div><div class="line">[path addLineToPoint:CGPointMake(200, 150)];</div><div class="line"></div><div class="line">//create shape layer</div><div class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">shapeLayer.lineWidth = 5;</div><div class="line">shapeLayer.lineJoin = kCALineJoinRound;</div><div class="line">shapeLayer.lineCap = kCALineCapRound;</div><div class="line">shapeLayer.path = path.CGPath;</div><div class="line">//add it to our view</div><div class="line">[self.containerView.layer addSublayer:shapeLayer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.1.png" alt="image"></p>
<h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>第二章里面提到了<code>CAShapeLayer</code>为创建圆角视图提供了一个方法，就是<code>CALayer</code>的<code>cornerRadius</code>属性。虽然使用<code>CAShapeLayer</code>类需要更多的工作，但是它有一个优势就是可以单独指定每个角。</p>
<p>我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上<code>UIBezierPath</code>有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//define path parameters</div><div class="line">CGRect rect = CGRectMake(50, 50, 100, 100);</div><div class="line">CGSize radii = CGSizeMake(20, 20);</div><div class="line">UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;</div><div class="line">//create path</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</div></pre></td></tr></table></figure>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把<code>CAShapeLayer</code>作为视图的宿主图层，而不是添加一个子视图（图层蒙板的详细解释见第四章『视觉效果』）。</p>
<h2 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h2><p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。</p>
<p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。</p>
<p>万幸的是这些都是不必要的，Core Animation提供了一个CALayer的子类<code>CATextLayer</code>，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，<code>CATextLayer</code>也要比<code>UILabel</code>渲染得快得多。很少有人知道在iOS 6及之前的版本，<code>UILabel</code>其实是通过<code>WebKit</code>来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而<code>CATextLayer</code>使用了<code>Core text</code>，并且渲染得非常快。</p>
<p>让我们来尝试用<code>CATextLayer</code>来显示一些文字。清单6.2的代码实现了这一功能，结果如图6.2所示。</p>
<p>清单6.2 用CATextLayer来实现一个UILabel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create a text layer</div><div class="line">CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">textLayer.frame = self.labelView.bounds;</div><div class="line">[self.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">textLayer.foregroundColor = [UIColor blackColor].CGColor;</div><div class="line">textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">textLayer.wrapped = YES;</div><div class="line"></div><div class="line">//choose a font</div><div class="line">UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line"></div><div class="line">//set layer font</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">textLayer.font = fontRef;</div><div class="line">textLayer.fontSize = font.pointSize;</div><div class="line">CGFontRelease(fontRef);</div><div class="line"></div><div class="line">//choose some text</div><div class="line">NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line"></div><div class="line">//set layer text</div><div class="line">textLayer.string = text;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.2.png" alt=""></p>
<p>图6.2 用<code>CATextLayer</code>来显示一个纯文本标签</p>
<p>如果你仔细看这个文本，你会发现一个奇怪的地方：这些文本有一些像素化了。这是因为并没有以Retina的方式渲染，第二章提到了这个<code>contentScale</code>属性，用来决定图层内容应该以怎样的分辨率来渲染。<code>contentsScale</code>并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下：</p>
<p>textLayer.contentsScale = [UIScreen mainScreen].scale;<br>这样就解决了这个问题（如图6.3）</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.3.png" alt="i"></p>
<p>图6.3 设置contentsScale来匹配屏幕</p>
<p><code>CATextLayer</code>的<code>font</code>属性不是一个<code>UIFont</code>类型，而是一个<code>CFTypeRef</code>类型。这样可以根据你的具体需要来决定字体属性应该是用<code>CGFontRef</code>类型还是<code>CTFontRef</code>类型（Core Text字体）。同时字体大小也是用<code>fontSize</code>属性单独设置的，因为<code>CTFontRef</code>和<code>CGFontRef</code>并不像<code>UIFont</code>一样包含点大小。这个例子会告诉你如何将<code>UIFont</code>转换成<code>CGFontRef</code>。</p>
<p>另外，<code>CATextLayer</code>的<code>string</code>属性并不是你想象的<code>NSString</code>类型，而是<code>id</code>类型。这样你既可以用<code>NSString</code>也可以用<code>NSAttributedString</code>来指定文本了（注意，<code>NSAttributedString</code>并不是<code>NSString</code>的子类）。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>
<h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><p>iOS 6中，Apple给<code>UILabel</code>和其他UIKit文本视图添加了直接的属性化字符串的支持，应该说这是一个很方便的特性。不过事实上从iOS3.2开始<code>CATextLayer</code>就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，CATextLayer无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用UIWebView的麻烦。</p>
<p>让我们编辑一下示例使用到<code>NSAttributedString</code>（见清单6.3）.iOS 6及以上我们可以用新的<code>NSTextAttributeName</code>实例来设置我们的字符串属性，但是练习的目的是为了演示在iOS 5及以下，所以我们用了<code>Core Text</code>，也就是说你需要把Core Text framework添加到你的项目中。否则，编译器是无法识别属性常量的。</p>
<p>图6.4是代码运行结果（注意那个红色的下划线文本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;CoreText/CoreText.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create a text layer</div><div class="line">CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">textLayer.frame = self.labelView.bounds;</div><div class="line">textLayer.contentsScale = [UIScreen mainScreen].scale;</div><div class="line">[self.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">textLayer.wrapped = YES;</div><div class="line"></div><div class="line">//choose a font</div><div class="line">UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line"></div><div class="line">//choose some text</div><div class="line">NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line">￼</div><div class="line">//create attributed string</div><div class="line">NSMutableAttributedString *string = nil;</div><div class="line">string = [[NSMutableAttributedString alloc] initWithString:text];</div><div class="line"></div><div class="line">//convert UIFont to a CTFont</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFloat fontSize = font.pointSize;</div><div class="line">CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);</div><div class="line"></div><div class="line">//set text attributes</div><div class="line">NSDictionary *attribs = @&#123;</div><div class="line">(__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,</div><div class="line">(__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[string setAttributes:attribs range:NSMakeRange(0, [text length])];</div><div class="line">attribs = @&#123;</div><div class="line">(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,</div><div class="line">(__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),</div><div class="line">(__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">&#125;;</div><div class="line">[string setAttributes:attribs range:NSMakeRange(6, 5)];</div><div class="line"></div><div class="line">//release the CTFont we created earlier</div><div class="line">CFRelease(fontRef);</div><div class="line"></div><div class="line">//set layer text</div><div class="line">textLayer.string = string;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="行距和字距"><a href="#行距和字距" class="headerlink" title="行距和字距"></a>行距和字距</h3><p>有必要提一下的是，由于绘制的实现机制不同（Core Text和WebKit），用<code>CATextLayer</code>渲染和用<code>UILabel</code>渲染出的文本行距和字距也不是不尽相同的。</p>
<p>二者的差异程度（由使用的字体和字符决定）总的来说挺小，但是如果你想正确的显示普通便签和<code>CATextLayer</code>就一定要记住这一点。</p>
<h3 id="UILabel的替代品"><a href="#UILabel的替代品" class="headerlink" title="UILabel的替代品"></a>UILabel的替代品</h3><p>我们已经证实了<code>CATextLayer</code>比<code>UILabel</code>有着更好的性能表现，同时还有额外的布局选项并且在iOS 5上支持富文本。但是与一般的标签比较而言会繁琐一些。如果我们真的在需求一个UILabel的可用替代品，最好是能够在Interface Builder上创建我们的标签，而且尽可能地像一般的视图一样正常工作。</p>
<p>我们应该继承UILabel，然后添加一个子图层CATextLayer并重写显示文本的方法。但是仍然会有由UILabel的<code>-drawRect:</code>方法创建的空寄宿图。而且由于<code>CALayer</code>不支持自动缩放和自动布局，子视图并不是主动跟踪视图边界的大小，所以每次视图大小被更改，我们不得不手动更新子图层的边界。</p>
<p>我们真正想要的是一个用<code>CATextLayer</code>作为宿主图层的<code>UILabel</code>子类，这样就可以随着视图自动调整大小而且也没有冗余的寄宿图啦。</p>
<p>就像我们在第一章『图层树』讨论的一样，每一个UIView都是寄宿在一个CALayer的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用<code>+layerClass</code>方法，然后用它的返回类型来创建宿主图层。</p>
<p>清单6.4 演示了一个UILabel子类<code>LayerLabel</code>用CATextLayer绘制它的问题，而不是调用一般的UILabel使用的较慢的<code>-drawRect：</code>方法。<code>LayerLabel</code>示例既可以用代码实现，也可以在Interface Builder实现，只要把普通的标签拖入视图之中，然后设置它的类是LayerLabel就可以了。<br>清单6.4 使用<code>CATextLayer的UILabel</code>子类：<code>LayerLabel</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#import &quot;LayerLabel.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@implementation LayerLabel</div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">//this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer</div><div class="line">return [CATextLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CATextLayer *)textLayer</div><div class="line">&#123;</div><div class="line">return (CATextLayer *)self.layer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//set defaults from UILabel settings</div><div class="line">self.text = self.text;</div><div class="line">self.textColor = self.textColor;</div><div class="line">self.font = self.font;</div><div class="line"></div><div class="line">//we should really derive these from the UILabel settings too</div><div class="line">//but that&apos;s complicated, so for now we&apos;ll just hard-code them</div><div class="line">[self textLayer].alignmentMode = kCAAlignmentJustified;</div><div class="line">￼</div><div class="line">[self textLayer].wrapped = YES;</div><div class="line">[self.layer display];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//called when creating label programmatically</div><div class="line">if (self = [super initWithFrame:frame]) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">//called when creating label using Interface Builder</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setText:(NSString *)text</div><div class="line">&#123;</div><div class="line">super.text = text;</div><div class="line">//set layer text</div><div class="line">[self textLayer].string = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setTextColor:(UIColor *)textColor</div><div class="line">&#123;</div><div class="line">super.textColor = textColor;</div><div class="line">//set layer text color</div><div class="line">[self textLayer].foregroundColor = textColor.CGColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setFont:(UIFont *)font</div><div class="line">&#123;</div><div class="line">super.font = font;</div><div class="line">//set layer font</div><div class="line">CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">[self textLayer].font = fontRef;</div><div class="line">[self textLayer].fontSize = font.pointSize;</div><div class="line">￼</div><div class="line">CGFontRelease(fontRef);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果你运行代码，你会发现文本并没有像素化，而我们也没有设置<code>contentsScale</code>属性。把<code>CATextLayer</code>作为宿主图层的另一好处就是视图自动设置了<code>contentsScale</code>属性。</p>
<p>在这个简单的例子中，我们只是实现了<code>UILabel</code>的一部分风格和布局属性，不过稍微再改进一下我们就可以创建一个支持<code>UILabel</code>所有功能甚至更多功能的LayerLabel类（你可以在一些线上的开源项目中找到）。</p>
<p>如果你打算支持iOS 6及以上，基于<code>CATextLayer</code>的标签可能就有有些局限性。但是总得来说，如果想在app里面充分利用<code>CALayer</code>子类，用<code>+layerClass</code>来创建基于不同图层的视图是一个简单可复用的方法。</p>
<h2 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h2><p>当我们在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。比如说，你想创造一个孩子的手臂：你就需要确定哪一部分是孩子的手腕，哪一部分是孩子的前臂，哪一部分是孩子的肘，哪一部分是孩子的上臂，哪一部分是孩子的肩膀等等。</p>
<p>当然是允许独立地移动每个区域的啦。以肘为指点会移动前臂和手，而不是肩膀。Core Animation图层很容易就可以让你在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的孩子都平面化到一个场景中（第五章『变换』有提到）。</p>
<p><code>CATransformLayer</code>解决了这个问题，<code>CATransformLayer</code>不同于普通的<code>CALayer</code>，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。<code>CATransformLayer</code>并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，比如我的手臂示例。</p>
<p>用代码创建一个手臂需要相当多的代码，所以我就演示得更简单一些吧：在第五章的立方体示例，我们将通过旋转camara来解决图层平面化问题而不是像立方体示例代码中用的<code>sublayerTransform</code>。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>
<p>那么，就让我们来试一试<code>CATransformLayer</code>吧，第一个问题就来了：在第五章，我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的UIView子类寄宿在CATransformLayer（用+layerClass方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像第五章一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>
<p>清单6.5就是代码。我们以我们在第五章使用过的相同基本逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个CATransformLayer中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是光亮来区分他们。图6.5是运行结果。</p>
<p>… 此处省略三千字</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p><code>CAGradientLayer</code>是用来生成两种或更多颜色平滑渐变的。用<code>Core Graphics</code>复制一个<code>CAGradientLayer</code>并将内容绘制到一个普通图层的寄宿图也是有可能的，但是<code>CAGradientLayer</code>的真正好处在于绘制使用了硬件加速。</p>
<h3 id="基础渐变"><a href="#基础渐变" class="headerlink" title="基础渐变"></a>基础渐变</h3><p>我们将从一个简单的红变蓝的对角线渐变开始（见清单6.6）.这些渐变色彩放在一个数组中，并赋给<code>colors</code>属性。这个数组成员接受<code>CGColorRef</code>类型的值（并不是从NSObject派生而来），所以我们要用通过bridge转换以确保编译正常。</p>
<p><code>CAGradientLayer</code>也有<code>startPoint</code>和<code>endPoint</code>属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是<code>{0, 0}</code>，右下角坐标是<code>{1, 1}</code>。代码运行结果如图6.6</p>
<p>清单6.6 简单的两种颜色的对角线渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create gradient layer and add it to our container view</div><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">//set gradient colors</div><div class="line">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];</div><div class="line"></div><div class="line">//set gradient start and end points</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="多重渐变"><a href="#多重渐变" class="headerlink" title="多重渐变"></a>多重渐变</h3><p>如果你愿意，<code>colors</code>属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用<code>locations</code>属性来调整空间。<code>locations</code>属性是一个浮点数值的数组（以<code>NSNumber</code>包装）。这些浮点数定义了<code>colors</code>属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。</p>
<p><code>locations</code>数组并不是强制要求的，但是如果你给它赋值了就一定要确保<code>locations</code>的数组大小和<code>colors</code>数组大小一定要相同，否则你将会得到一个空白的渐变。</p>
<p>清单6.7展示了一个基于清单6.6的对角线渐变的代码改造。现在变成了从红到黄最后到绿色的渐变。<code>locations</code>数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。（如图6.7）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">[super viewDidLoad];</div><div class="line"></div><div class="line">//create gradient layer and add it to our container view</div><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">//set gradient colors</div><div class="line">gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];</div><div class="line"></div><div class="line">//set locations</div><div class="line">gradientLayer.locations = @[@0.0, @0.25, @0.5];</div><div class="line"></div><div class="line">//set gradient start and end points</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h2><p><code>CAReplicatorLayer</code>的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。看上去演示能够更加解释这些，我们来写个例子吧。</p>
<p>变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上，图6.8是代码运行结果。</p>
<p>清单6.8 用<code>CAReplicatorLayer</code>重复图层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">//create a replicator layer and add it to our view</div><div class="line">CAReplicatorLayer *replicator = [CAReplicatorLayer layer];</div><div class="line">replicator.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:replicator];</div><div class="line"></div><div class="line">//configure the replicator</div><div class="line">replicator.instanceCount = 10;</div><div class="line"></div><div class="line">//apply a transform for each instance</div><div class="line">CATransform3D transform = CATransform3DIdentity;</div><div class="line">transform = CATransform3DTranslate(transform, 0, 200, 0);</div><div class="line">transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);</div><div class="line">transform = CATransform3DTranslate(transform, 0, -200, 0);</div><div class="line">replicator.instanceTransform = transform;</div><div class="line"></div><div class="line">//apply a color shift for each instance</div><div class="line">replicator.instanceBlueOffset = -0.1;</div><div class="line">replicator.instanceGreenOffset = -0.1;</div><div class="line"></div><div class="line">//create a sublayer and place it inside the replicator</div><div class="line">CALayer *layer = [CALayer layer];</div><div class="line">layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);</div><div class="line">layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">[replicator addSublayer:layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.8.png" alt="image"></p>
<p>注意到当图层在重复的时候，他们的颜色也在变化：这是用<code>instanceBlueOffset</code>和<code>instanceGreenOffset</code>属性实现的。通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是CAReplicatorLayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了CAEmitterLayer，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：反射。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>使用<code>CAReplicatorLayer</code>并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果。让我们来尝试实现这个创意：指定一个继承于<code>UIView的ReflectionView</code>，它会自动产生内容的反射效果。实现这个效果的代码很简单（见清单6.9），实际上用<code>ReflectionView</code>实现这个效果会更简单，我们只需要把<code>ReflectionView</code>的实例放置于Interface Builder（见图6.9），它就会实时生成子视图的反射，而不需要别的代码（见图6.10）.</p>
<p>清单6.9 用CAReplicatorLayer自动绘制反射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#import &quot;ReflectionView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@implementation ReflectionView</div><div class="line"></div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">return [CAReplicatorLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//configure replicator</div><div class="line">CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;</div><div class="line">layer.instanceCount = 2;</div><div class="line"></div><div class="line">//move reflection instance below original and flip vertically</div><div class="line">CATransform3D transform = CATransform3DIdentity;</div><div class="line">CGFloat verticalOffset = self.bounds.size.height + 2;</div><div class="line">transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);</div><div class="line">transform = CATransform3DScale(transform, 1, -1, 0);</div><div class="line">layer.instanceTransform = transform;</div><div class="line"></div><div class="line">//reduce alpha of reflection layer</div><div class="line">layer.instanceAlphaOffset = -0.6;</div><div class="line">&#125;</div><div class="line">￼</div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//this is called when view is created in code</div><div class="line">if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib</div><div class="line">&#123;</div><div class="line">//this is called when view is created from a nib</div><div class="line">[self setUp];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.10.png" alt=""></p>
<p>开源代码ReflectionView完成了一个自适应的渐变淡出效果（用CAGradientLayer和图层蒙板实现），代码见 <a href="https://github.com/nicklockwood/ReflectionView" target="_blank" rel="external">https://github.com/nicklockwood/ReflectionView</a></p>
<h2 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h2><p>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。</p>
<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到UITableView或是UIScrollView，但是对于独立的图层来说，什么会等价于刚刚提到的UITableView和UIScrollView呢？</p>
<p>在第二章中，我们探索了图层的contentsRect属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>
<p>这个时候就需要CAScrollLayer了。CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<p>让我们来用CAScrollLayer来常见一个基本的UIScrollView替代品。我们将会用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应。这段代码见清单6.10. 图6.11是运行效果：ScrollView显示了一个大于它的frame的UIImageView。</p>
<p>清单6.10 用CAScrollLayer实现滑动视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#import &quot;ScrollView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt; @implementation ScrollView</div><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">return [CAScrollLayer class];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setUp</div><div class="line">&#123;</div><div class="line">//enable clipping</div><div class="line">self.layer.masksToBounds = YES;</div><div class="line"></div><div class="line">//attach pan gesture recognizer</div><div class="line">UIPanGestureRecognizer *recognizer = nil;</div><div class="line">recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</div><div class="line">[self addGestureRecognizer:recognizer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">//this is called when view is created in code</div><div class="line">if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">//this is called when view is created from a nib</div><div class="line">[self setUp];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)pan:(UIPanGestureRecognizer *)recognizer</div><div class="line">&#123;</div><div class="line">//get the offset by subtracting the pan gesture</div><div class="line">//translation from the current bounds origin</div><div class="line">CGPoint offset = self.bounds.origin;</div><div class="line">offset.x -= [recognizer translationInView:self].x;</div><div class="line">offset.y -= [recognizer translationInView:self].y;</div><div class="line"></div><div class="line">//scroll the layer</div><div class="line">[(CAScrollLayer *)self.layer scrollToPoint:offset];</div><div class="line"></div><div class="line">//reset the pan gesture translation</div><div class="line">[recognizer setTranslation:CGPointZero inView:self];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>图6.11 用UIScrollView创建一个凑合的滑动视图</p>
<p>不同于UIScrollView，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</p>
<p>那你一定会奇怪用CAScrollLayer的意义到底何在，因为你可以简单地用一个普通的CALayer然后手动适应边界原点啊。真相其实并不复杂，UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</p>
<p>CAScrollLayer有一个潜在的有用特性。如果你查看CAScrollLayer的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)scrollPoint:(CGPoint)p;</div><div class="line">- (void)scrollRectToVisible:(CGRect)r;</div><div class="line">@property(readonly) CGRect visibleRect;</div></pre></td></tr></table></figure>
<p>看到这些方法和属性名，你也许会以为这些方法给每个CALayer实例增加了滑动功能。但是事实上他们只是放置在CAScrollLayer中的图层的实用方法。scrollPoint:方法从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。scrollRectToVisible:方法实现了同样的事情只不过是作用在一个矩形上的。visibleRect属性决定图层（如果存在的话）的哪部分是当前的可视区域。如果你自己实现这些方法就会相对容易明白一点，但是CAScrollLayer帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</p>
<h2 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h2><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的<code>-imageNamed:</code>方法或者<code>-imageWithContentsOfFile:</code>方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>
<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为<code>OpenGL</code>纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em>2048，或4096</em>4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p>
<p><code>CATiledLayer</code>为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</p>
<h3 id="小片裁剪"><a href="#小片裁剪" class="headerlink" title="小片裁剪"></a>小片裁剪</h3><p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从<code>CATiledLayer</code>中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那<code>CATiledLayer</code>这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>
<p>清单6.11 演示了一个简单的Mac OS命令行程序，它用<code>CATiledLayer</code>将一个图片裁剪成小图并存储到不同的文件中。</p>
<p>清单6.11 裁剪图片成小图的终端程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#import &lt;AppKit/AppKit.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[])</div><div class="line">&#123;</div><div class="line">@autoreleasepool&#123;</div><div class="line">￼//handle incorrect arguments</div><div class="line">if (argc &lt; 2) &#123;</div><div class="line">NSLog(@&quot;TileCutter arguments: inputfile&quot;);</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//input file</div><div class="line">NSString *inputFile = [NSString stringWithCString:argv[1] encoding:NSUTF8StringEncoding];</div><div class="line"></div><div class="line">//tile size</div><div class="line">CGFloat tileSize = 256; //output path</div><div class="line">NSString *outputPath = [inputFile stringByDeletingPathExtension];</div><div class="line"></div><div class="line">//load image</div><div class="line">NSImage *image = [[NSImage alloc] initWithContentsOfFile:inputFile];</div><div class="line">NSSize size = [image size];</div><div class="line">NSArray *representations = [image representations];</div><div class="line">if ([representations count])&#123;</div><div class="line">NSBitmapImageRep *representation = representations[0];</div><div class="line">size.width = [representation pixelsWide];</div><div class="line">size.height = [representation pixelsHigh];</div><div class="line">&#125;</div><div class="line">NSRect rect = NSMakeRect(0.0, 0.0, size.width, size.height);</div><div class="line">CGImageRef imageRef = [image CGImageForProposedRect:&amp;rect context:NULL hints:nil];</div><div class="line"></div><div class="line">//calculate rows and columns</div><div class="line">NSInteger rows = ceil(size.height / tileSize);</div><div class="line">NSInteger cols = ceil(size.width / tileSize);</div><div class="line"></div><div class="line">//generate tiles</div><div class="line">for (int y = 0; y &lt; rows; ++y) &#123;</div><div class="line">for (int x = 0; x &lt; cols; ++x) &#123;</div><div class="line">//extract tile image</div><div class="line">CGRect tileRect = CGRectMake(x*tileSize, y*tileSize, tileSize, tileSize);</div><div class="line">CGImageRef tileImage = CGImageCreateWithImageInRect(imageRef, tileRect);</div><div class="line"></div><div class="line">//convert to jpeg data</div><div class="line">NSBitmapImageRep *imageRep = [[NSBitmapImageRep alloc] initWithCGImage:tileImage];</div><div class="line">NSData *data = [imageRep representationUsingType: NSJPEGFileType properties:nil];</div><div class="line">CGImageRelease(tileImage);</div><div class="line"></div><div class="line">//save file</div><div class="line">NSString *path = [outputPath stringByAppendingFormat: @&quot;_%02i_%02i.jpg&quot;, x, y];</div><div class="line">[data writeToFile:path atomically:NO];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序将2048<em>2048分辨率的雪人图案裁剪成了64个不同的256</em>256的小图。（256*256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>
<blockquote>
<p>path/to/TileCutterApp path/to/Snowman.jpg</p>
</blockquote>
<h2 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h2><p>在iOS 5中，苹果引入了一个新的<code>CALayer</code>子类叫做<code>CAEmitterLayer</code>。<code>CAEmitterLayer</code>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<p><code>CAEmitterLayer</code>看上去像是许多<code>CAEmitterCell</code>的容器，这些<code>CAEmitierCell</code>定义了一个例子效果。你将会为不同的例子效果定义一个或多个<code>CAEmitterCell</code>作为模版，同时<code>CAEmitterLayer</code>负责基于这些模版实例化一个粒子流。一个<code>CAEmitterCell</code>类似于一个<code>CALayer：</code>它有一个<code>contents</code>属性可以定义为一个<code>CGImage</code>，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在<code>CAEmitterCell</code>类的头文件中找到。</p>
<p>我们来举个例子。我们将利用在一圆中发射不同速度和透明度的粒子创建一个火爆炸的效果。清单6.13包含了生成爆炸的代码。图6.13是运行结果</p>
<p>清单6.13 用<code>CAEmitterLayer</code>创建爆炸效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">[super viewDidLoad];</div><div class="line">￼</div><div class="line">//create particle emitter layer</div><div class="line">CAEmitterLayer *emitter = [CAEmitterLayer layer];</div><div class="line">emitter.frame = self.containerView.bounds;</div><div class="line">[self.containerView.layer addSublayer:emitter];</div><div class="line"></div><div class="line">//configure emitter</div><div class="line">emitter.renderMode = kCAEmitterLayerAdditive;</div><div class="line">emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);</div><div class="line"></div><div class="line">//create a particle template</div><div class="line">CAEmitterCell *cell = [[CAEmitterCell alloc] init];</div><div class="line">cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;</div><div class="line">cell.birthRate = 150;</div><div class="line">cell.lifetime = 5.0;</div><div class="line">cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;</div><div class="line">cell.alphaSpeed = -0.4;</div><div class="line">cell.velocity = 50;</div><div class="line">cell.velocityRange = 50;</div><div class="line">cell.emissionRange = M_PI * 2.0;</div><div class="line"></div><div class="line">//add particle template to emitter</div><div class="line">emitter.emitterCells = @[cell];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>CAEMitterCell的属性基本上可以分为三种：</p>
<ul>
<li>这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>例子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</li>
</ul>
<p><code>CAEmitterLayer</code>的属性它自己控制着整个例子系统的位置和形状。一些属性比如<code>birthRate</code>，<code>lifetime</code>和<code>celocity</code>，这些属性在<code>CAEmitterCell</code>中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：</p>
<ul>
<li><code>preservesDepth</code>，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li><code>renderMode</code>，控制着在视觉上粒子图片是如何混合的。你可能已经注意到了示例中我们把它设置为<code>kCAEmitterLayerAdditive</code>，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的<code>kCAEmitterLayerUnordered</code>，效果就没那么好看了（见图6.14）.<br><img src="http://wiki.jikexueyuan.com/project/ios-core-animation/images/6.14.png" alt="i"></li>
</ul>
<p>图6.14 禁止混色之后的火焰粒子</p>
<h2 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h2><p>当iOS要处理高性能图形绘制，必要时就是OpenGL。应该说它应该是最后的杀手锏，至少对于非游戏的应用来说是的。因为相比Core Animation和UIkit框架，它不可思议地复杂。</p>
<p>OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。用起来非常复杂和强大，但是用OpenGL绘制iOS用户界面就需要很多很多的工作了。</p>
<p>为了能够以高性能使用Core Animation，你需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果你想绘制的东西并不能找到标准的图层类，想要得到高性能就比较费事情了。</p>
<p>因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<p>大部分情况下你都不需要手动设置CAEAGLLayer（假设用GLKView），过去的日子就不要再提了。特别的，我们将设置一个OpenGL ES 2.0的上下文，它是现代的iOS设备的标准做法。</p>
<p>尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，这些都以类C语言叫做GLSL自包含在程序中，同时在运行时载入到图形硬件中。编写GLSL代码和设置EAGLayer没有什么关系，所以我们将用GLKBaseEffect类将着色逻辑抽象出来。其他的事情，我们还是会有以往的方式。</p>
<p>在开始之前，你需要将GLKit和OpenGLES框架加入到你的项目中，然后就可以实现清单6.14中的代码，里面是设置一个GAEAGLLayer的最少工作，它使用了OpenGL ES 2.0 的绘图上下文，并渲染了一个有色三角（见图6.15）.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/06/图层几何学/" rel="next" title="图层几何学">
                <i class="fa fa-chevron-left"></i> 图层几何学
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#专用图层"><span class="nav-number">1.</span> <span class="nav-text">专用图层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAShapeLayer"><span class="nav-number">1.1.</span> <span class="nav-text">CAShapeLayer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个CGPath"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建一个CGPath</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#圆角"><span class="nav-number">1.2.</span> <span class="nav-text">圆角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CATextLayer"><span class="nav-number">1.3.</span> <span class="nav-text">CATextLayer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#富文本"><span class="nav-number">1.4.</span> <span class="nav-text">富文本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#行距和字距"><span class="nav-number">1.4.1.</span> <span class="nav-text">行距和字距</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UILabel的替代品"><span class="nav-number">1.4.2.</span> <span class="nav-text">UILabel的替代品</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CATransformLayer"><span class="nav-number">1.5.</span> <span class="nav-text">CATransformLayer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAGradientLayer"><span class="nav-number">1.6.</span> <span class="nav-text">CAGradientLayer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础渐变"><span class="nav-number">1.6.1.</span> <span class="nav-text">基础渐变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重渐变"><span class="nav-number">1.6.2.</span> <span class="nav-text">多重渐变</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAReplicatorLayer"><span class="nav-number">1.7.</span> <span class="nav-text">CAReplicatorLayer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">1.7.1.</span> <span class="nav-text">反射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAScrollLayer"><span class="nav-number">1.8.</span> <span class="nav-text">CAScrollLayer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CATiledLayer"><span class="nav-number">1.9.</span> <span class="nav-text">CATiledLayer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小片裁剪"><span class="nav-number">1.9.1.</span> <span class="nav-text">小片裁剪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAEmitterLayer"><span class="nav-number">1.10.</span> <span class="nav-text">CAEmitterLayer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAEAGLLayer"><span class="nav-number">1.11.</span> <span class="nav-text">CAEAGLLayer</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
